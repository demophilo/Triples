#!/usr/bin/env python
# coding: utf-8


#  The functions calculate all possible, nontrivial triangles with three integer edges
#  and either 60, 90 or 120 degrees according to a given integer.
#  Output is a list of lists of triples and angles.
#  The first edge is opposite to the first angle and so on.
#  The function triple_60 calculates 60° and 120° triangles.
#  The argument switch has three different values.
#  switch = 60 calculates only 60° triangles.
#  switch = 120 calculates only 120° triangles.
#  switch = *any other value* calculates 60° and 120° triangles in one go.


import math
from operator import itemgetter


def angel_by_cos_law(*triangle, edge=0):
    """At first the opposite edge of the angle to be calculated is swapped to the first place."""
    if edge == 1:
        triangle[1], triangle[0] = triangle[0], triangle[1]
    elif edge == 2:
        triangle[2], triangle[0] = triangle[0], triangle[2]

    _angle = math.degrees(math.acos((triangle[1] ** 2 + triangle[2] ** 2 - triangle[0] ** 2) /
                                    (2 * triangle[1] * triangle[2])))
    return _angle


def trojan_triple_mnil(num1, num2):
    """Trojan triple calculated by development point (-1, 0)"""
    _edge0 = abs(num2 ** 2 - num1 ** 2)
    _edge1 = abs(2 * num1 * num2 - num1 ** 2)
    _edge2 = abs(num1 ** 2 + num2 ** 2 - num1 * num2)
    _triple = sorted([_edge0, _edge1, _edge2])

    return _triple


def trojan_triple_mm(num1, num2):
    """ Trojan triple calculated by development point (-1, -1)"""
    _edge0 = abs(2 * num1 * num2 - num1 ** 2)
    _edge1 = abs(2 * num1 * num2 - num2 ** 2)
    _edge2 = abs(num1 ** 2 + num2 ** 2 - num1 * num2)
    _triple = sorted([_edge0, _edge1, _edge2])

    return _triple


def trojan_triple_nilm(num1, num2):
    """Trojan triple calculated by development point (0, -1)"""
    _edge0 = abs(num1 ** 2 - num2 ** 2)
    _edge1 = abs(2 * num1 * num2 - num2 ** 2)
    _edge2 = abs(num1 ** 2 + num2 ** 2 - num1 * num2)
    _triple = sorted([_edge0, _edge1, _edge2])

    return _triple


def triple_90(pos_int):
    """
    List of every possible pythagorean triple for a given number is calculated.
    One pythagorean triple is generated by an integer number and a smaller integer number.
    The bigger number has to go from 2 to just above the half of the given number.
    The smaller number has to go from 1 to the bigger number minus 1
    """
    _n = int(math.ceil(pos_int / 2) + 1)
    _triple = []
    for _p in range(2, _n):
        for _q in range(1, _p):
            _a = 2 * _p * _q
            _b = _p ** 2 - _q ** 2
            _c = _p ** 2 + _q ** 2
            if _b < _a:
                _a, _b = _b, _a

            if pos_int % _a == 0:
                _an = pos_int
                _bn = int(_b * pos_int / _a)
                _cn = int(_c * pos_int / _a)
                _triple_i = [_an, _bn, _cn]
                if _triple_i not in _triple:
                    _triple.append(_triple_i)

            if pos_int % _b == 0:
                _bn = pos_int
                _an = int(_a * pos_int / _b)
                _cn = int(_c * pos_int / _b)
                _triple_i = [_an, _bn, _cn]
                if _triple_i not in _triple:
                    _triple.append(_triple_i)

            if pos_int % _c == 0:
                _cn = pos_int
                _bn = int(_b * pos_int / _c)
                _an = int(_a * pos_int / _c)
                _triple_i = [_an, _bn, _cn]
                if _triple_i not in _triple:
                    _triple.append(_triple_i)

    for _i in range(len(_triple)):
        _triple[_i].append(math.degrees(math.asin(_triple[_i][0] / _triple[_i][2])))
        _triple[_i].append(math.degrees(math.asin(_triple[_i][1] / _triple[_i][2])))
        _triple[_i].append(90)

    _sorted_winkel = sorted(_triple, key=itemgetter(3))
    return _sorted_winkel


# if __name__ == "__main__":
    # for p in range(-4, 5):
    #     for q in range(-p + 1, p - 1):
    #         print(trojan_triple_mnil(p, q))


def tester(func):
    _grenze = 4
    trojan_triples = []
    for p in range(-_grenze, _grenze+1):
        for q in range(-p + 1, p):
            if p != -1 and \
                    p != 0 and \
                    p != 1 and \
                    q != 0 and \
                    func(p, q)[0] != func(p, q)[1] and \
                    func(p, q)[0] != 0:
                trojan_triples.append(func(p, q))

    for i in range(len(trojan_triples)):
        print(trojan_triples[i])



# for num in range(3, 5):
#         print(num, len(triple_90(num)))
#         for i in range(len(triple_90(num))):
#             print(triple_90(num)[i])
