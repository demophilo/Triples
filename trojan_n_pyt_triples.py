#!/usr/bin/env python
# coding: utf-8


#  The functions calculate all possible, nontrivial triangles with three integer edges
#  and either 60, 90 or 120 degrees according to a given integer.
#  Output is a list of lists of triples and angles.
#  The first edge is opposite to the first angle and so on.
#  The function triple_60 calculates 60° and 120° triangles.
#  The argument switch has three different values.
#  switch = 60 calculates only 60° triangles.
#  switch = 120 calculates only 120° triangles.
#  switch = *any other value* calculates 60° and 120° triangles in one go.


import math
from operator import itemgetter


def angel_by_cos_law(*triangle, edge=0):
    # At first the opposite edge of the angle to be calculated is swapped to the first place.
    if edge == 1:
        triangle[1], triangle[0] = triangle[0], triangle[1]
    elif edge == 2:
        triangle[2], triangle[0] = triangle[0], triangle[2]

    # Cosine law
    _angle = math.degrees(math.acos((triangle[1] ** 2 + triangle[2] ** 2 - triangle[0] ** 2) / \
                                    (2 * triangle[1] * triangle[2])))
    return _angle

# Trojan triple calculated by development point (-1, 0)
def trojan_triple_mnil(num1, num2):
    _edge0 = abs(num2 ** 2 - num1 ** 2)
    _edge1 = abs(2 * num1 * num2 - num1 ** 2)
    _edge2 = abs(num1 ** 2 + num2 ** 2 - num1 * num2)
    _triple = sorted[_edge0, _edge1, _edge2]

    return _triple

# Trojan triple calculated by development point (-1, -1)
def trojan_triple_mm(num1, num2):
    _edge0 = abs(2 * num1 * num2 - num1 ** 2)
    _edge1 = abs(2 * num1 * num2 - num2 ** 2)
    _edge2 = abs(num1 ** 2 + num2 ** 2 - num1 * num2)
    _triple = sorted[_edge0, _edge1, _edge2]

    return _triple

# Trojan triple calculated by development point (0, -1)
def trojan_triple_nilm(num1, num2):
    _edge0 = abs(num1 ** 2 - num2 ** 2)
    _edge1 = abs(2 * num1 * num2 - num2 ** 2)
    _edge2 = abs(num1 ** 2 + num2 ** 2 - num1 * num2)
    _triple = sorted[_edge0, _edge1, _edge2]

    return _triple

# List of every possible pythagorean triple for a given number is calculated.
# One pythagorean triple is generated by an integer number and a smaller integer number.
# The bigger number has to go from 2 to just above the half of the given number.
# The smaller number has to go from 1 to the bigger number minus 1.
def triple_90(num):
    _n = int(math.ceil(num / 2) + 1)
    _triple = []
    for _p in range(2, _n):
        for _q in range(1, _p):
            _a = 2 * _p * _q
            _b = _p ** 2 - _q ** 2
            _c = _p ** 2 + _q ** 2
            if _b < _a:
                _a, _b = _b, _a

            if num % _a == 0:
                _an = num
                _bn = int(_b * num / _a)
                _cn = int(_c * num / _a)
                _triple_i = [_an, _bn, _cn]
                if _triple_i not in _triple:
                    _triple.append(_triple_i)

            if num % _b == 0:
                _bn = num
                _an = int(_a * num / _b)
                _cn = int(_c * num / _b)
                _triple_i = [_an, _bn, _cn]
                if _triple_i not in _triple:
                    _triple.append(_triple_i)

            if num % _c == 0:
                _cn = num
                _bn = int(_b * num / _c)
                _an = int(_a * num / _c)
                _triple_i = [_an, _bn, _cn]
                if _triple_i not in _triple:
                    _triple.append(_triple_i)
    for _i in range(len(_triple)):
        _triple[_i].append(math.degrees(math.asin(_triple[_i][0] / _triple[_i][2])))
        _triple[_i].append(math.degrees(math.asin(_triple[_i][1] / _triple[_i][2])))
        _triple[_i].append(90)
    _sorted_winkel = sorted(_triple, key=itemgetter(3))
    return _sorted_winkel

if __name__ == "__main__":

    for num in range(3, 37):
        print(num, len(triple_90(num)))
        for i in range(len(triple_90(num))):
            print(triple_90(num)[i])
